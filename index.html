<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Unicode Match-3</title>
<style>
/* â”€â”€â”€ Reset & Base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --cell: clamp(44px, 11vw, 72px);
  --gap: clamp(3px, 0.8vw, 6px);
  --radius: 10px;
  --bg: #0d0d1a;
  --panel: #13132b;
  --border: #2a2a4a;
  --text: #e8e8f4;
  --accent: #7b68ee;
  --accent2: #ff6b9d;
  --gold: #ffd700;

  /* Family colours â€” subtle bg tints */
  --f0: #1a1a3e; --f0b: #4444cc;
  --f1: #1e2a1a; --f1b: #44aa44;
  --f2: #2a1a1a; --f2b: #cc4444;
  --f3: #2a1e1a; --f3b: #cc7744;
  --f4: #1a2a2a; --f4b: #44aaaa;
  --f5: #221a2a; --f5b: #9944cc;
  --f6: #2a2a1a; --f6b: #aaaa44;
  --f7: #1a2222; --f7b: #44ccaa;
}

html, body {
  height: 100%;
  background: var(--bg);
  color: var(--text);
  font-family: 'Segoe UI', system-ui, sans-serif;
  overflow: hidden;
  touch-action: none;
}

/* â”€â”€â”€ Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#app {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  height: 100%;
  gap: 12px;
  padding: 12px 8px;
  overflow-y: auto;
}

/* â”€â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#header {
  display: flex;
  gap: 16px;
  align-items: center;
  flex-wrap: wrap;
  justify-content: center;
  width: 100%;
  max-width: 640px;
}

.stat-box {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px 14px;
  text-align: center;
  min-width: 80px;
}
.stat-box .label {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: #888;
}
.stat-box .value {
  font-size: 20px;
  font-weight: 700;
  color: var(--gold);
  line-height: 1.2;
}

#combo-display {
  font-size: 13px;
  color: var(--accent2);
  font-weight: 600;
  min-width: 80px;
  text-align: center;
  min-height: 20px;
}

/* â”€â”€â”€ Board wrapper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#board-wrap {
  position: relative;
  flex-shrink: 0;
}

#board {
  display: grid;
  grid-template-columns: repeat(8, var(--cell));
  grid-template-rows: repeat(8, var(--cell));
  gap: var(--gap);
  padding: var(--gap);
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 16px;
  position: relative;
  user-select: none;
}

/* â”€â”€â”€ Tile â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.tile {
  width: var(--cell);
  height: var(--cell);
  border-radius: var(--radius);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: clamp(20px, 5vw, 34px);
  cursor: pointer;
  position: relative;
  border: 2px solid transparent;
  transition:
    transform 120ms ease,
    border-color 80ms ease,
    background 80ms ease;
  /* line-height forces monospace-ish sizing */
  line-height: 1;
  font-family: 'Segoe UI Symbol', 'Apple Color Emoji', 'Noto Sans Symbols', monospace;
}

/* Family background tints */
.tile[data-fid="0"] { background: var(--f0); }
.tile[data-fid="1"] { background: var(--f1); }
.tile[data-fid="2"] { background: var(--f2); }
.tile[data-fid="3"] { background: var(--f3); }
.tile[data-fid="4"] { background: var(--f4); }
.tile[data-fid="5"] { background: var(--f5); }
.tile[data-fid="6"] { background: var(--f6); }
.tile[data-fid="7"] { background: var(--f7); }

/* Highlight mode borders */
body.highlight .tile[data-fid="0"] { border-color: var(--f0b); }
body.highlight .tile[data-fid="1"] { border-color: var(--f1b); }
body.highlight .tile[data-fid="2"] { border-color: var(--f2b); }
body.highlight .tile[data-fid="3"] { border-color: var(--f3b); }
body.highlight .tile[data-fid="4"] { border-color: var(--f4b); }
body.highlight .tile[data-fid="5"] { border-color: var(--f5b); }
body.highlight .tile[data-fid="6"] { border-color: var(--f6b); }
body.highlight .tile[data-fid="7"] { border-color: var(--f7b); }

/* Selection */
.tile.selected {
  border-color: var(--accent) !important;
  transform: scale(1.08);
  z-index: 2;
  box-shadow: 0 0 0 3px rgba(123,104,238,0.4);
}

/* Keyboard cursor */
.tile.cursor {
  outline: 3px dashed var(--accent2);
  outline-offset: 2px;
  z-index: 3;
}

/* Hover */
.tile:hover:not(.clearing):not(.dropping) {
  filter: brightness(1.3);
}

/* Special tile badge */
.tile .badge {
  position: absolute;
  top: 2px;
  right: 3px;
  font-size: 10px;
  line-height: 1;
  opacity: 0.9;
}

/* â”€â”€â”€ Animations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@keyframes pop {
  0%   { transform: scale(1); }
  40%  { transform: scale(1.25); }
  70%  { transform: scale(0.9); }
  100% { transform: scale(0); opacity: 0; }
}

@keyframes drop-in {
  from { transform: translateY(calc(-1 * var(--cell) * 2)); opacity: 0; }
  to   { transform: translateY(0); opacity: 1; }
}

@keyframes settle {
  0%   { transform: translateY(0); }
  25%  { transform: translateY(-6px); }
  55%  { transform: translateY(3px); }
  80%  { transform: translateY(-2px); }
  100% { transform: translateY(0); }
}

@keyframes jiggle {
  0%   { transform: translateX(0); }
  20%  { transform: translateX(8px); }
  40%  { transform: translateX(-8px); }
  60%  { transform: translateX(5px); }
  80%  { transform: translateX(-3px); }
  100% { transform: translateX(0); }
}

@keyframes flash-special {
  0%   { filter: brightness(1) saturate(1); }
  50%  { filter: brightness(2.5) saturate(2); }
  100% { filter: brightness(1) saturate(1); }
}

@keyframes board-shuffle {
  0%   { opacity: 1; transform: scale(1) rotate(0deg); }
  50%  { opacity: 0.3; transform: scale(0.92) rotate(2deg); }
  100% { opacity: 1; transform: scale(1) rotate(0deg); }
}

.tile.clearing {
  animation: pop 220ms ease-out forwards;
  pointer-events: none;
  z-index: 5;
}

.tile.dropping {
  animation: drop-in 200ms ease-out forwards;
}

.tile.settling {
  animation: settle 260ms ease-out;
}

.tile.jiggling {
  animation: jiggle 300ms ease-out;
}

.tile.flash-special {
  animation: flash-special 180ms ease-out;
}

#board.shuffling {
  animation: board-shuffle 400ms ease-in-out;
}

/* â”€â”€â”€ Floating score text â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.float-score {
  position: absolute;
  font-size: 14px;
  font-weight: 700;
  color: var(--gold);
  pointer-events: none;
  z-index: 100;
  animation: float-up 900ms ease-out forwards;
  text-shadow: 0 1px 3px rgba(0,0,0,0.8);
  white-space: nowrap;
}

@keyframes float-up {
  0%   { opacity: 1; transform: translateY(0) scale(1); }
  30%  { opacity: 1; transform: translateY(-18px) scale(1.15); }
  100% { opacity: 0; transform: translateY(-52px) scale(0.8); }
}

/* â”€â”€â”€ Controls bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#controls {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: center;
}

button {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text);
  padding: 7px 14px;
  font-size: 13px;
  cursor: pointer;
  transition: background 120ms, border-color 120ms;
}
button:hover { background: #1e1e40; border-color: var(--accent); }
button:active { transform: scale(0.97); }

/* â”€â”€â”€ Palette info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#palette-info {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  justify-content: center;
  max-width: 640px;
  font-size: 12px;
}

.family-chip {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 20px;
  padding: 3px 10px;
  display: flex;
  gap: 5px;
  align-items: center;
}
.family-chip .sample { font-size: 16px; }

/* â”€â”€â”€ Overlay (game over / reshuffle message) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.75);
  align-items: center;
  justify-content: center;
  z-index: 200;
  backdrop-filter: blur(4px);
}
#overlay.show { display: flex; }

#overlay-box {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 20px;
  padding: 32px 40px;
  text-align: center;
  max-width: 340px;
}
#overlay-box h2 { font-size: 28px; margin-bottom: 12px; }
#overlay-box p  { color: #aaa; margin-bottom: 20px; font-size: 15px; }
#overlay-box button {
  font-size: 16px;
  padding: 10px 28px;
  border-color: var(--accent);
  background: rgba(123,104,238,0.15);
}

/* â”€â”€â”€ Keyboard hint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#key-hint {
  font-size: 11px;
  color: #555;
  text-align: center;
}
</style>
</head>
<body>

<div id="app">
  <div id="header">
    <div class="stat-box">
      <div class="label">Score</div>
      <div class="value" id="score-display">0</div>
    </div>
    <div class="stat-box">
      <div class="label">Best</div>
      <div class="value" id="best-display">0</div>
    </div>
    <div class="stat-box">
      <div class="label">Moves</div>
      <div class="value" id="moves-display">0</div>
    </div>
    <div id="combo-display"></div>
  </div>

  <div id="board-wrap">
    <div id="board" tabindex="0" role="grid" aria-label="Match-3 game board"></div>
  </div>

  <div id="controls">
    <button id="btn-new">New Game</button>
    <button id="btn-palette">Next Palette</button>
    <button id="btn-highlight">Toggle Colors</button>
    <button id="btn-seed">Daily Seed</button>
  </div>

  <div id="palette-info"></div>

  <div id="key-hint">
    Keyboard: Arrow keys move cursor Â· Space selects/swaps Â· Click or drag tiles
  </div>
</div>

<div id="overlay">
  <div id="overlay-box">
    <h2 id="overlay-title">Reshuffling!</h2>
    <p id="overlay-msg">No moves found. Board is being shuffled.</p>
    <button id="overlay-btn">Continue</button>
  </div>
</div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION 1 â€” SEEDED RNG
   A simple, deterministic PRNG (mulberry32) so same seed â†’
   same board. Daily seed = yyyymmdd integer.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function mulberry32(seed) {
  return function() {
    seed |= 0;
    seed = seed + 0x6D2B79F5 | 0;
    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

function todaySeed() {
  const d = new Date();
  return d.getFullYear() * 10000 + (d.getMonth() + 1) * 100 + d.getDate();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION 2 â€” PALETTES
   Each palette has families. Matching is by familyId index.
   Each family has a name and an array of glyphs (display variants).
   We pick one glyph per tile from the family (cosmetic only).
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const PALETTES = [
  {
    name: "Arrows & Shapes",
    families: [
      { name: "Cardinal Arrows", glyphs: ["â†","â†’","â†‘","â†“"] },
      { name: "Diagonal Arrows", glyphs: ["â†—","â†˜","â†™","â†–"] },
      { name: "Double Arrows",   glyphs: ["â‡","â‡’","â‡‘","â‡“"] },
      { name: "Circles",         glyphs: ["â—","â—‹","â—‰","â—"] },
      { name: "Squares",         glyphs: ["â– ","â–¡","â–ª","â–«"] },
      { name: "Triangles",       glyphs: ["â–²","â–¼","â—€","â–¶"] },
    ]
  },
  {
    name: "Math & Logic",
    families: [
      { name: "Relations",  glyphs: ["=","â‰ ","â‰ˆ","â‰¡"] },
      { name: "Operations", glyphs: ["+","âˆ’","Ã—","Ã·"] },
      { name: "Sets",       glyphs: ["âˆˆ","âˆ‰","âŠ‚","âŠƒ"] },
      { name: "Logic",      glyphs: ["âˆ§","âˆ¨","Â¬","âŠ•"] },
      { name: "Quantifiers",glyphs: ["âˆ€","âˆƒ","âˆ„","âˆ…"] },
      { name: "Calculus",   glyphs: ["âˆ‚","âˆ‡","âˆ«","âˆ‘"] },
    ]
  },
  {
    name: "Weather & Nature",
    families: [
      { name: "Sun",    glyphs: ["â˜€","â˜¼","ğŸŒ¤","â›…"] },
      { name: "Cloud",  glyphs: ["â˜","â›…","ğŸŒ§","ğŸŒ©"] },
      { name: "Moon",   glyphs: ["â˜½","â˜¾","ğŸŒ™","ğŸŒ›"] },
      { name: "Snow",   glyphs: ["â„","â…","â†","â›„"] },
      { name: "Bolt",   glyphs: ["âš¡","â˜‡","â˜ˆ","â›ˆ"] },
      { name: "Wave",   glyphs: ["ã€°","â‰‹","âˆ¿","ã€œ"] },
    ]
  },
  {
    name: "Ancient & Runes",
    families: [
      { name: "Rune A", glyphs: ["áš ","áš¢","áš¦","áš¨"] },
      { name: "Rune B", glyphs: ["áš±","áš²","áš·","áš¹"] },
      { name: "Rune C", glyphs: ["ášº","áš¾","á›","á›ƒ"] },
      { name: "Rune D", glyphs: ["á›‡","á›ˆ","á›‰","á›Š"] },
      { name: "Rune E", glyphs: ["á›","á›’","á›–","á›—"] },
      { name: "Rune F", glyphs: ["á›š","á›œ","á›","á›Ÿ"] },
    ]
  },
  {
    name: "Card Suits & Stars",
    families: [
      { name: "Spades",   glyphs: ["â™ ","â™¤","ğŸ‚¡","ğŸ‚¢"] },
      { name: "Hearts",   glyphs: ["â™¥","â™¡","ğŸ‚±","ğŸ‚²"] },
      { name: "Diamonds", glyphs: ["â™¦","â™¢","ğŸƒ","ğŸƒ‚"] },
      { name: "Clubs",    glyphs: ["â™£","â™§","ğŸƒ‘","ğŸƒ’"] },
      { name: "Stars",    glyphs: ["â˜…","â˜†","âœ¦","âœ§"] },
      { name: "Flowers",  glyphs: ["âœ¿","â€","â","âƒ"] },
    ]
  }
];

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION 3 â€” CONSTANTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const ROWS = 8;
const COLS = 8;
const FAMILY_COUNT = 6; // how many families active per game

const SPECIAL = {
  NONE:  0,
  ROW:   1,   // clears entire row
  COL:   2,   // clears entire column
  BOMB:  3,   // 3Ã—3 radius
  CROSS: 4,   // row + col
};

const SPECIAL_BADGE = {
  [SPECIAL.ROW]:   "â†”",
  [SPECIAL.COL]:   "â†•",
  [SPECIAL.BOMB]:  "âœ¸",
  [SPECIAL.CROSS]: "âœ›",
};

const SPECIAL_SCORE = {
  [SPECIAL.ROW]:   50,
  [SPECIAL.COL]:   50,
  [SPECIAL.BOMB]:  75,
  [SPECIAL.CROSS]: 100,
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION 4 â€” GAME STATE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let state = {
  board: [],          // 2D array [row][col] â†’ Tile | null
  score: 0,
  best: 0,
  moves: 0,
  paletteIdx: 0,
  rng: null,
  seed: 0,
  busy: false,        // prevents input during animations

  // input
  selected: null,     // {r, c} of first click
  cursor: {r: 0, c: 0},   // keyboard cursor
  dragStart: null,    // {r, c, x, y}
};

/* Tile shape:
   { familyId: number, glyph: string, special: SPECIAL }
*/

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION 5 â€” BOARD GENERATION
   Fill without creating any 3-in-a-row matches.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function makeTile(familyId, glyph, special = SPECIAL.NONE) {
  return { familyId, glyph, special };
}

function randomGlyph(rng, familyId) {
  const fam = currentPalette().families[familyId];
  return fam.glyphs[Math.floor(rng() * fam.glyphs.length)];
}

function generateBoard(rng) {
  const board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      // build a pool excluding ids that would create a match
      const excluded = new Set();

      // check horizontal: left-left and left
      if (c >= 2 &&
          board[r][c-1] && board[r][c-2] &&
          board[r][c-1].familyId === board[r][c-2].familyId) {
        excluded.add(board[r][c-1].familyId);
      }
      // check vertical: up-up and up
      if (r >= 2 &&
          board[r-1][c] && board[r-2][c] &&
          board[r-1][c].familyId === board[r-2][c].familyId) {
        excluded.add(board[r-1][c].familyId);
      }

      const pool = [];
      for (let f = 0; f < FAMILY_COUNT; f++) {
        if (!excluded.has(f)) pool.push(f);
      }

      // should always have at least one option, but guard anyway
      const familyId = pool.length > 0
        ? pool[Math.floor(rng() * pool.length)]
        : Math.floor(rng() * FAMILY_COUNT);

      board[r][c] = makeTile(familyId, randomGlyph(rng, familyId));
    }
  }
  return board;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION 6 â€” MATCH DETECTION
   Returns a Set of "r,c" strings and per-match metadata.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function detectMatches(board) {
  const matched = new Set();    // "r,c" â†’ will be cleared
  const matchGroups = [];       // [{cells, dir, length}]

  // Horizontal runs
  for (let r = 0; r < ROWS; r++) {
    let run = 1;
    for (let c = 1; c <= COLS; c++) {
      const prev = board[r][c-1];
      const curr = c < COLS ? board[r][c] : null;
      const cont = curr && prev && curr.familyId === prev.familyId;

      if (!cont) {
        if (run >= 3) {
          const cells = [];
          for (let k = c - run; k < c; k++) cells.push({r, c: k});
          cells.forEach(pos => matched.add(`${pos.r},${pos.c}`));
          matchGroups.push({ cells, dir: 'h', length: run });
        }
        run = 1;
      } else {
        run++;
      }
    }
  }

  // Vertical runs
  for (let c = 0; c < COLS; c++) {
    let run = 1;
    for (let r = 1; r <= ROWS; r++) {
      const prev = board[r-1][c];
      const curr = r < ROWS ? board[r][c] : null;
      const cont = curr && prev && curr.familyId === prev.familyId;

      if (!cont) {
        if (run >= 3) {
          const cells = [];
          for (let k = r - run; k < r; k++) cells.push({r: k, c});
          cells.forEach(pos => matched.add(`${pos.r},${pos.c}`));
          matchGroups.push({ cells, dir: 'v', length: run });
        }
        run = 1;
      } else {
        run++;
      }
    }
  }

  return { matched, matchGroups };
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION 7 â€” SPECIAL TILE CREATION
   Called once per player-initiated swap (not during cascades).
   movedTo: {r,c} â€” the tile the player dragged/swapped *into*.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function computeSpecials(board, matchGroups, movedTo, isPlayerSwap) {
  if (!isPlayerSwap) return; // cascades don't create specials

  // Find which match groups contain the movedTo cell
  for (const group of matchGroups) {
    const hasMovedTo = group.cells.some(pos => pos.r === movedTo.r && pos.c === movedTo.c);
    if (!hasMovedTo) continue;

    const len = group.length;
    const tile = board[movedTo.r][movedTo.c];
    if (!tile) continue;

    // T/L shape detection: does this run overlap another run?
    const isComplex = matchGroups.some(g =>
      g !== group &&
      g.dir !== group.dir &&
      g.cells.some(pos => group.cells.some(p => p.r === pos.r && p.c === pos.c))
    );

    let special = SPECIAL.NONE;
    if (isComplex) {
      special = SPECIAL.BOMB;
    } else if (len === 4) {
      special = group.dir === 'h' ? SPECIAL.ROW : SPECIAL.COL;
    } else if (len >= 5) {
      special = SPECIAL.CROSS;
    }

    if (special !== SPECIAL.NONE) {
      // Place special on movedTo cell (if it hasn't been marked for clear yet,
      // we'll handle that by converting the tile in place)
      tile.special = special;
    }
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION 8 â€” CLEARING + SPECIAL ACTIVATION
   Returns set of {r,c} cells to clear (union of matched + specials).
   Uses a queue so chain reactions propagate.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function expandClears(board, initialMatched) {
  const toClear = new Set(initialMatched); // "r,c"
  const queue = [...initialMatched];       // "r,c" strings
  const activatedSpecials = [];

  while (queue.length > 0) {
    const key = queue.shift();
    const [r, c] = key.split(',').map(Number);
    const tile = board[r]?.[c];
    if (!tile || tile.special === SPECIAL.NONE) continue;

    activatedSpecials.push({ r, c, special: tile.special });

    // Gather cells affected by this special
    let affected = [];
    if (tile.special === SPECIAL.ROW) {
      for (let cc = 0; cc < COLS; cc++) affected.push({r, c: cc});
    } else if (tile.special === SPECIAL.COL) {
      for (let rr = 0; rr < ROWS; rr++) affected.push({r: rr, c});
    } else if (tile.special === SPECIAL.BOMB) {
      for (let dr = -1; dr <= 1; dr++)
        for (let dc = -1; dc <= 1; dc++) {
          const nr = r + dr, nc = c + dc;
          if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS)
            affected.push({r: nr, c: nc});
        }
    } else if (tile.special === SPECIAL.CROSS) {
      for (let cc = 0; cc < 
